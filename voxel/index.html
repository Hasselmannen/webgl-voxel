<html>
<head>
<title>Voxel</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="gl-stuff.js"></script>
<script type="text/javascript" src="voxel-stuff.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="texture.js"></script>

<script type="text/javascript">
    // Shaders
    var shaders = {
        pre       : { src : "shaders/pre" },
        deferred  : { src : "shaders/deferred" },
        shadowmap : { src : "shaders/shadowmap" }
    };

    // Render matrices
    var modelViewMatrix = mat4.create();
    var projectionMatrix = mat4.create();
    var shadowMapProjectionMatrix = mat4.create();
    var shadowMapModelViewMatrices = new Array();

    var lightPos = [8, 8, 8];
    var viewSpaceLightPos = new Array();

    var camera = new Camera([8, 8, 19], [0, 0, -1]);

    var chunks = new Array();

    var preFramebuffer;
    var shadowMapFramebuffer;
    var shadowMapFramebuffers;

    var normalDepthTexture;
    var normalTexture;
    var diffuseTexture;
    var cubeTexture;
    var depthTexture;
    var shadowMapTexture;

    var sceneFarPlane = 100;
    var shadowMapFarPlane = 100;
    var shadowMapSize = 512;

    var targetFPS = 60;
    var targetDelta = 1000/targetFPS;

    var moveSpeed = 0.1;
    var rotateSpeed = 0.05;

    function linkProgram(gl, shader) {
        var program = gl.createProgram();
        var vs = gl.createShader(gl.VERTEX_SHADER);
        var fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(vs, shader.vs);
        gl.compileShader(vs);
        
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
            alert(shader.src + gl.getShaderInfoLog(vs));
            return null;
        }
        
        gl.shaderSource(fs, shader.fs);
        gl.compileShader(fs);
        
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(fs));
            return null;
        }
        
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            alert("Could not initialise shader: " + shader);
            return null;
        }
        
        return program;
    }

    function initShader(shader, attributes, uniforms) {
        var program = linkProgram(gl, shader);
        gl.useProgram(program);

        program.attributes = {};
        program.uniforms = {};

        for (val of attributes) {
            program.attributes[val] = gl.getAttribLocation(program, val);
            gl.enableVertexAttribArray(program.attributes[val]);
        }

        for (val of uniforms) {
            program.uniforms[val] = gl.getUniformLocation(program, val);
        }

        return program;
    }

    function reloadShader(shader) {
        gl.deleteProgram(shader.program);
        return initShader(shader, Object.keys(shader.program.attributes), Object.keys(shader.program.uniforms));
    }

    function initShaders() {
        shaders.pre.program = initShader(
            shaders.pre,
            ["position", "normal", "tangent", "bitangent", "texCoordIn"],
            ["projectionMatrix", "modelViewMatrix", "normalTexture", "diffuseTexture", "depthMap"]
        );
        shaders.shadowmap.program = initShader(
            shaders.shadowmap,
            ["position"],
            ["projectionMatrix", "modelViewMatrix"]
        );
        shaders.deferred.program = initShader(
            shaders.deferred,
            ["position"],
            ["normalDepthTexture", "diffuseTexture", "viewSpaceLightPos", "invProjectionMatrix", "shadowMap", "invModelViewMatrix", "noiseTexture", "hemisphere", "projectionMatrix"]
        );
    }

    function setPreUniforms() {
        gl.uniformMatrix4fv(shaders.pre.program.uniforms["projectionMatrix"], false, projectionMatrix);
        gl.uniformMatrix4fv(shaders.pre.program.uniforms["modelViewMatrix"], false, modelViewMatrix);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
        gl.uniform1i(shaders.pre.program.uniforms["diffuseTexture"], 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, normalTexture);
        gl.uniform1i(shaders.pre.program.uniforms["normalTexture"], 1);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, depthMap);
        gl.uniform1i(shaders.pre.program.uniforms["depthMap"], 2);
        gl.activeTexture(gl.TEXTURE0);
    }
    function setDeferredUniforms() {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.uniform1i(shaders.deferred.program.uniforms["normalDepthTexture"], 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, diffuseTexture);
        gl.uniform1i(shaders.deferred.program.uniforms["diffuseTexture"], 1);
        gl.uniform3fv(shaders.deferred.program.uniforms["viewSpaceLightPos"], viewSpaceLightPos);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, shadowMapTexture);
        gl.uniform1i(shaders.deferred.program.uniforms["shadowMap"], 2);

        gl.activeTexture(gl.TEXTURE3);
        gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
        gl.uniform1i(shaders.deferred.program.uniforms["noiseTexture"], 3);
        gl.uniform3fv(shaders.deferred.program.uniforms["hemisphere"], hemisphereArray);
        gl.uniformMatrix4fv(shaders.deferred.program.uniforms["projectionMatrix"], false, projectionMatrix);
        
        var invProjectionMatrix = mat4.create();
        mat4.inverse(projectionMatrix, invProjectionMatrix);
        gl.uniformMatrix4fv(shaders.deferred.program.uniforms["invProjectionMatrix"], false, invProjectionMatrix);
        gl.activeTexture(gl.TEXTURE0);

        var invModelViewMatrix = mat4.create();
        mat4.inverse(modelViewMatrix, invModelViewMatrix);
        gl.uniformMatrix4fv(shaders.deferred.program.uniforms["invModelViewMatrix"], false, invModelViewMatrix);
    }
    function setShadowMapUniforms(face) {
        gl.uniformMatrix4fv(shaders.shadowmap.program.uniforms["projectionMatrix"], false, shadowMapProjectionMatrix);
        gl.uniformMatrix4fv(shaders.shadowmap.program.uniforms["modelViewMatrix"], false, shadowMapModelViewMatrices[face]);
    }

    function initFramebuffers(width, height) {

        normalTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, normalTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 255, 255]));
        var image2 = new Image();
        image2.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, normalTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image2.src = cubeTextureData.normalMap;

        cubeTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
        var image = new Image();
        image.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image.src = cubeTextureData.data;

        
        depthMap = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthMap);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
        var image3 = new Image();
        image3.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, depthMap);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image3);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image3.src = cubeTextureData.depthMap;
        
        var depthExt = gl.getExtension("WEBGL_depth_texture");
        if (!depthExt) {
            console.log("no depth textures");
        }

        diffuseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, diffuseTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        normalDepthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        depthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);

        // PRE FRAMEBUFFER
        preFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, preFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, mrtExt.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, diffuseTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, mrtExt.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, normalDepthTexture, 0);

        mrtExt.drawBuffersWEBGL([
            mrtExt.COLOR_ATTACHMENT0_WEBGL,
            mrtExt.COLOR_ATTACHMENT1_WEBGL
        ]);

        shadowMapFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffer);
        // SHADOW MAP STUFF
        shadowMapTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, shadowMapTexture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        for (var i = 0; i < 6; i++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, shadowMapSize, shadowMapSize, 0, gl.RGBA, gl.FLOAT, null);
        }

        var shadowMapDepthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, shadowMapDepthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, shadowMapSize, shadowMapSize);

        shadowMapFramebuffers = new Array(6);
        for (var i = 0; i < 6; i++) {
            // Different framebuffers for every face, it is much faster:
            // http://jsperf.com/webgl-cubemap-fbo-change-face-test
            shadowMapFramebuffers[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, shadowMapTexture, 0);
            
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, shadowMapDepthBuffer);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function handleInput(delta) {
        if (isKeyDown(38) || isKeyDown(87)) { // UP / W
            camera.move([0, 0, moveSpeed * delta]);
        }
        if (isKeyDown(37) || isKeyDown(65)) { // LEFT / A
            camera.rotate([0, rotateSpeed * delta, 0]);
        }
        if (isKeyDown(40) || isKeyDown(83)) { // DOWN / S
            camera.move([0, 0, -moveSpeed * delta]);
        }
        if (isKeyDown(39) || isKeyDown(68)) { // RIGHT / D
            camera.rotate([0, -rotateSpeed * delta, 0]);
        }
        if (isKeyDown(81)) { // Q
            camera.move([-moveSpeed * delta, 0, 0]);
        }
        if (isKeyDown(69)) { // E
            camera.move([moveSpeed * delta, 0, 0]);
        }
    }

    function setupScene() {
        var chunk = new Chunk();
        chunk.SetActive(7, 8, 7, true);
        chunk.SetActive(7, 9, 7, true);
        chunk.SetActive(7, 9, 8, true);
        chunk.SetActive(8, 9, 7, true);

        chunk.SetActive(9, 8, 9, true);
        chunk.SetActive(9, 7, 8, true);
        chunk.SetActive(9, 7, 9, true);
        chunk.SetActive(8, 7, 9, true);

        chunk.SetActive(1, 7, 8, true);
        chunk.SetActive(1, 8, 8, true);
        chunk.SetActive(1, 9, 8, true);

        chunk.SetActive(3, 7, 8, true);
        chunk.SetActive(3, 8, 8, true);
        chunk.SetActive(3, 9, 8, true);

        chunk.SetActive(5, 7, 8, true);
        chunk.SetActive(5, 8, 8, true);
        chunk.SetActive(5, 9, 8, true);

        for (var i = 0; i < Chunk.SIZE; i++) {
            for (var j = 0; j < Chunk.SIZE; j++) {
                chunk.SetActive(i, 6, j, true); // Floor
                chunk.SetActive(i, 10, j, true); // Ceiling
                chunk.SetActive(i, j, 6, true); // Far wall
            }
        }
        chunk.CreateMesh();
        chunks.push(chunk);
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, sceneFarPlane, projectionMatrix);

        modelViewMatrix = camera.viewMatrix();

        mat4.multiplyVec3(modelViewMatrix, lightPos, viewSpaceLightPos);

        gl.bindFramebuffer(gl.FRAMEBUFFER, preFramebuffer);
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 100.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.useProgram(shaders.pre.program);
        setPreUniforms();

        for (var i = 0; i < chunks.length; i++) {
            chunks[i].SetPositions(shaders.pre.program);
            chunks[i].SetNormals(shaders.pre.program);
            chunks[i].SetTangents(shaders.pre.program);
            chunks[i].SetBitangents(shaders.pre.program);
            chunks[i].SetTexCoords(shaders.pre.program);
            chunks[i].Render(shaders.pre.program);
        }
    }

    function drawShadowMap() {
        mat4.perspective(90, 1, 0.1, shadowMapFarPlane, shadowMapProjectionMatrix);
        shadowMapModelViewMatrices[0] = mat4.lookAt(lightPos, [lightPos[0] + 1, lightPos[1], lightPos[2]], [0, -1,  0]);
        shadowMapModelViewMatrices[1] = mat4.lookAt(lightPos, [lightPos[0] - 1, lightPos[1], lightPos[2]], [0, -1,  0]);
        shadowMapModelViewMatrices[2] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1] + 1, lightPos[2]], [0,  0,  1]);
        shadowMapModelViewMatrices[3] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1] - 1, lightPos[2]], [0,  0, -1]);
        shadowMapModelViewMatrices[4] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1], lightPos[2] + 1], [0, -1,  0]);
        shadowMapModelViewMatrices[5] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1], lightPos[2] - 1], [0, -1,  0]);

        gl.clearColor(shadowMapFarPlane, shadowMapFarPlane, shadowMapFarPlane, shadowMapFarPlane);
        gl.viewport(0, 0, shadowMapSize, shadowMapSize);
        for (var i = 0; i < 6; i++) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffers[i]);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(shaders.shadowmap.program);
            setShadowMapUniforms(i);

            for (var j = 0; j < chunks.length; j++) {
                chunks[j].SetPositions(shaders.shadowmap.program);
                chunks[j].Render(shaders.shadowmap.program);
            }
        }
    }
var numSSAOSamples = 64;
var noiseTexture;
var hemisphereArray;
    function generateSSAOhemisphere() {
        hemisphereArray = new Array();
        for (var i = 0; i < numSSAOSamples; i++) {
            var hemisphere = [
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random()
            ];
            vec3.normalize(hemisphere);
            vec3.scale(hemisphere, Math.random());
            
            var scale = i / numSSAOSamples;
            scale = (1 - scale * scale) * 0.1 + scale * scale; // Lerp
            vec3.scale(hemisphere, scale);
            hemisphereArray = hemisphereArray.concat(hemisphere);
        }
    }
    function generateSSAONoiseTexture() {
        var noiseTextureSize = 4;
        var noiseArray = new Array();
        for (var i = 0; i < noiseTextureSize * noiseTextureSize * 3; i += 3) {
            var noise = [
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                0
            ];
            vec3.normalize(noise);
            noiseArray = noiseArray.concat(noise);
        }
        noiseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, noiseTextureSize, noiseTextureSize, 0, gl.RGB, gl.FLOAT, new Float32Array(noiseArray));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }

    function drawDeferred() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.useProgram(shaders.deferred.program);
        setDeferredUniforms();
        drawFullscreenQuad(shaders.deferred.program);
    }

    function render() {
        drawScene();
        drawShadowMap();
        drawDeferred();
    }

    function webGLStart() {
        // Init everything
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        
        initFramebuffers(gl.viewportWidth, gl.viewportHeight);

        setupScene();

        generateSSAOhemisphere();
        generateSSAONoiseTexture();

        // Setup permanent stuff
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);

        var stats1 = new frameTimeStats(10, document.getElementById("fps-text1"));
        var stats2 = new frameTimeStats(50, document.getElementById("fps-text2"));
        var stats3 = new frameTimeStats(100, document.getElementById("fps-text3"));

        var rendererInformation = new rendererInfo(document.getElementById("renderer-info"));

        var time = 0;

        // Start the game loop
        var last = performance.now();
        (function gameLoop(now){
            var delta = now - last;
            
            stats1.addSample(delta);
            stats2.addSample(delta);
            stats3.addSample(delta);

            rendererInformation.display();

            handleInput(delta/targetDelta);
            render();

            time += delta;
            lightPos[0] = 8 + Math.sin(time / 1000.0);

            last = now;

            requestAnimationFrame(gameLoop);
        })(performance.now());
    }

    function init() {
        loadShaders(webGLStart);
    }
    
    function loadShaders(callback) {
        var numRequests = 2 * Object.keys(shaders).length;
        var completedRequests = 0;
        
        for (var k in shaders) {
            ["vs", "fs"].forEach(function(ext) {
                var httpRequest = new XMLHttpRequest();
                (function(k) {
                    httpRequest.onreadystatechange = function() {
                        if (httpRequest.readyState == XMLHttpRequest.DONE) {
                            if (httpRequest.status === 200) {
                                shaders[k][ext] = httpRequest.responseText;
                                if (++completedRequests >= numRequests) {
                                    callback();
                                }
                            }
                            else {
                                alert(shaders[k] + "." + ext + " could not be loaded.");
                            }
                        }
                    };
                })(k);
                httpRequest.open("GET", shaders[k].src + "." + ext, true);
                httpRequest.send();
            });
        }
    }
</script>
</head>
<body onload="init();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
    <p id="fps-text1"></p>
    <p id="fps-text2"></p>
    <p id="fps-text3"></p>
    <p id="renderer-info"></p>
    
    <p>
        <label for="number-god-ray-samples">Number of God Ray samples:</label>
        <input type="number" id="number-god-ray-samples" min="0" max="100" value="100" />
    </p>
    <p>
        <label for="number-ssao-samples">Number of SSAO samples:</label>
        <input type="number" id="number-ssao-samples" min="0" max="100" value="64" />
    </p>
    <p>
        <label for="enable-parallax">Enable Parallax Mapping: </label>
        <input type="checkbox" id="enable-parallax" checked />
    </p>
        <p>
        <label for="enable-normal-mapping">Enable Normal Mapping: </label>
        <input type="checkbox" id="enable-normal-mapping" checked />
    </p>
        <p>
        <label for="enable-diffuse-texture">Enable Diffuse Texture: </label>
        <input type="checkbox" id="enable-diffuse-texture" checked />
    </p>
    <script type="text/javascript">

    function setDefined(text, define, string, value) {
        return text.replace(
            new RegExp("(#undef|#define)\\s+" + string + "( +\\S+)?"),
            (define ? "#define " : "#undef ") + string + (value != null ? " " + value : "")
        );
    }
    
    var numGodRaySamplesInput = document.getElementById("number-god-ray-samples");
    var numSSAOSamplesInput = document.getElementById("number-ssao-samples");
    var parallaxInput = document.getElementById("enable-parallax");
    var normalMappingInput = document.getElementById("enable-normal-mapping");
    var diffuseTextureInput = document.getElementById("enable-diffuse-texture");
    
    numGodRaySamplesInput.onchange = function() {
        shaders.deferred.fs = setDefined(shaders.deferred.fs, true,
                                         "NUM_CREPUSCULAR_SAMPLES",
                                         numGodRaySamplesInput.value);
        shaders.deferred.program = reloadShader(shaders.deferred);
    }

    numSSAOSamplesInput.onchange = function() {
        var value = numSSAOSamplesInput.value;
        numSSAOSamples = value;
        if (value == null || value <= 0) {
            shaders.deferred.fs = setDefined(shaders.deferred.fs, false, "ENABLE_SSAO");
        }
        else {
            shaders.deferred.fs = setDefined(shaders.deferred.fs, true, "ENABLE_SSAO");
            shaders.deferred.fs = setDefined(shaders.deferred.fs, true,
                                             "NUM_SSAO_SAMPLES",
                                             value);
        }
        shaders.deferred.program = reloadShader(shaders.deferred);
    }
    
    parallaxInput.onchange = function() {
        shaders.pre.fs = setDefined(shaders.pre.fs, parallaxInput.checked, "PARALLAX_MAPPING");
        shaders.pre.program = reloadShader(shaders.pre);
    }
    
    normalMappingInput.onchange = function() {
        shaders.pre.fs = setDefined(shaders.pre.fs, normalMappingInput.checked, "NORMAL_MAPPING");
        shaders.pre.program = reloadShader(shaders.pre);
    }
    
    diffuseTextureInput.onchange = function() {
        shaders.pre.fs = setDefined(shaders.pre.fs, diffuseTextureInput.checked, "DIFFUSE_TEXTURE");
        shaders.pre.program = reloadShader(shaders.pre);
    }
    </script>
</body>
</html>
