<html>
<head>
<title>Voxel</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="gl-stuff.js"></script>
<script type="text/javascript" src="voxel-stuff.js"></script>
<script type="text/javascript" src="util.js"></script>
<script type="text/javascript" src="texture.js"></script>

<script id="pre-vs" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 position;
    attribute vec3 normal;
    attribute vec3 tangent;
    attribute vec3 bitangent;
    attribute vec2 texCoordIn;

    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 viewSpaceNormal;
    varying vec3 viewSpacePosition;
    varying mat3 invTBN;
    varying mat3 TBN;
    varying vec2 texCoord;

    varying vec3 tangentSpacePosition;
    
    void main(void) {
        viewSpacePosition = vec3(modelViewMatrix * vec4(position, 1));
        viewSpaceNormal = vec3(modelViewMatrix * vec4(normal, 0));
        gl_Position = projectionMatrix * vec4(viewSpacePosition, 1);

        vec3 T = normalize(modelViewMatrix * vec4(tangent, 0.0)).xyz;
        vec3 B = normalize(modelViewMatrix * vec4(bitangent, 0.0)).xyz;
        vec3 N = normalize(modelViewMatrix * vec4(normal, 0.0)).xyz;

        invTBN = mat3(T, B, N);

        TBN = mat3(
            T.x, B.x, N.x,
            T.y, B.y, N.y,
            T.z, B.z, N.z
        );
        
        tangentSpacePosition = TBN * viewSpacePosition;
        
        texCoord = texCoordIn;
    }
</script>
<script id="pre-fs" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require

    precision highp float;

    uniform sampler2D diffuseTexture;
    uniform sampler2D normalTexture;
    uniform sampler2D depthMap;

    varying vec3 viewSpaceNormal;
    varying vec3 viewSpacePosition;
    varying vec3 tangentSpacePosition;
    varying mat3 TBN;
    varying mat3 invTBN;
    varying vec2 texCoord;
    
    #define PARALLAX_MAPPING
    #define MIN_LAYERS 16.0
    #define MAX_LAYERS 64.0
    #define HEIGHT_SCALE 0.1
    
    #define NORMAL_MAPPING
    #define DIFFUSE_TEXTURE
    
    vec2 parallax(vec2 texCoord, vec3 viewDir) {
        // Algorithm:
        // http://www.learnopengl.com/#!Advanced-Lighting/Parallax-Mapping
        float numLayers = mix(MAX_LAYERS, MIN_LAYERS, abs(dot(vec3(0, 0, 1), viewDir)));
        float layerDepth = 1.0 / numLayers;
        float currentDepth = 0.0;
        vec2 offset = viewDir.xy / viewDir.z * HEIGHT_SCALE;
        vec2 deltaTexCoord = offset / numLayers;
        
        float prevDepth = texture2D(depthMap, texCoord).r * 2.0 - 1.0;

        for (float i = 0.0; i < MAX_LAYERS; i += 1.0) {
            texCoord -= deltaTexCoord;
            prevDepth = texture2D(depthMap, texCoord).r * 2.0 - 1.0;
            currentDepth += layerDepth;
        
            if (currentDepth >= prevDepth) {
                break;
            }
        }
        
        vec2 prevTexCoord = texCoord + deltaTexCoord;
        
        float afterDepth = prevDepth - currentDepth;
        float beforeDepth = texture2D(depthMap, prevTexCoord).r - currentDepth + layerDepth;
        float weight = afterDepth / (afterDepth - beforeDepth);
        
        return prevTexCoord * weight + texCoord * (1.0 - weight);
    }
    
    void main(void) {
        #ifdef PARALLAX_MAPPING
        vec3 viewDir = normalize(tangentSpacePosition);
        vec2 newCoord = parallax(texCoord, viewDir);
        #else
        vec2 newCoord = texCoord;
        #endif
        
        #ifdef NORMAL_MAPPING
        vec3 normal = normalize(invTBN * (texture2D(normalTexture, newCoord).rgb * 2.0 - 1.0));
        #else
        vec3 normal = normalize(viewSpaceNormal);
        #endif

        #ifdef DIFFUSE_TEXTURE
        vec4 diffuseColor = texture2D(diffuseTexture, newCoord);
        #else
        vec4 diffuseColor = vec4(0.5, 0.5, 0.5, 1.0);
        #endif
        
        // TODO: Consider another pass to get correct depth after parallax mapping
        gl_FragData[0] = diffuseColor;
        gl_FragData[1] = vec4(normal, -viewSpacePosition.z);
    }
</script>

<script id="shadow-map-vs" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 position;

    uniform mat4 projectionMatrix;
    uniform mat4 modelViewMatrix;

    varying float distance;

    void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vec3 position = vec3(modelViewMatrix * vec4(position, 1));
        distance = dot(position, position);
    }
</script>
<script id="shadow-map-fs" type="x-shader/x-fragment">
    precision highp float;

    varying float distance;

    void main(void) {
        gl_FragColor = vec4(vec3(distance), 1);
    }
</script>

<script id="deferred-vs" type="x-shader/x-vertex">
    precision highp float;

    attribute vec2 position;

    uniform mat4 invProjectionMatrix;

    varying vec2 texCoord;
    varying vec3 farPlaneRay;

    const vec2 scale = vec2(0.5, 0.5);

    void main(void) {
        texCoord = position * scale + scale;
        farPlaneRay = (invProjectionMatrix * vec4(position, 0.0, 0.0)).xyz;
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>
<script id="deferred-fs" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 texCoord;
    varying vec3 farPlaneRay;

    uniform vec3 viewSpaceLightPos;
    uniform mat4 projectionMatrix;
    uniform mat4 invModelViewMatrix;
    uniform mat4 invProjectionMatrix;

    uniform sampler2D normalDepthTexture;
    uniform sampler2D diffuseTexture;
    uniform samplerCube shadowMap;

    #define ENABLE_SSAO
    #define NUM_SSAO_SAMPLES 64
    uniform sampler2D noiseTexture;
    uniform vec3 hemisphere[NUM_SSAO_SAMPLES];

    vec3 ambientLight = vec3(0.3, 0.3, 0.3);
    vec3 diffuseLight = vec3(0.9, 0.9, 0.5);
    vec3 specularLight = vec3(0.9, 0.9, 0.5);
    vec3 crepuscularLight = vec3(0.225, 0.225, 0.125);

    float materialShininess = 8.0;

    const float EPS1 = 0.0;
    const float EPS2 = 0.25;
    
    #define NUM_CREPUSCULAR_SAMPLES 100

    vec3 calculateAmbient(vec3 ambientLight, vec3 materialAmbient) {
        return ambientLight * materialAmbient;
    }

    vec3 calculateDiffuse(vec3 diffuseLight, vec3 materialDiffuse, float diffuseReflectance) {
        return diffuseLight * materialDiffuse * diffuseReflectance;
    }

    vec3 calculateFresnel(vec3 materialSpecular, vec3 normal, vec3 directionFromEye) {
        return materialSpecular + (vec3(1.0) - materialSpecular) * pow(clamp(1.0 + dot(directionFromEye, normal), 0.0, 1.0), 5.0);
    }

    vec3 calculateSpecular(vec3 specularLight, vec3 materialSpecular, float materialShininess, vec3 normal, vec3 directionToLight, vec3 directionFromEye) {
        float normalizationFactor = ((materialShininess + 2.0) / 8.0);
        vec3 h = normalize(directionToLight - directionFromEye);
        return specularLight * materialSpecular * pow(max(dot(h, normal), 0.0), materialShininess) * normalizationFactor;
    }

    bool inShadow(samplerCube shadowMap, mat4 invModelViewMatrix, vec3 vectorFromLight, float eps1, float eps2) {
        float nearestDepth = textureCube(shadowMap, mat3(invModelViewMatrix) * vectorFromLight).r;
        float distanceSquare = dot(vectorFromLight, vectorFromLight);
        return distanceSquare > eps1 + eps2 * distanceSquare / 10.0 + nearestDepth;
    }
    
    void main(void) {
        vec4 normalDepth = texture2D(normalDepthTexture, texCoord);
        vec4 colorRGBA = texture2D(diffuseTexture, texCoord);

        float depth = normalDepth.a;
        float alpha = colorRGBA.a;
        vec3 normal = normalize(normalDepth.rgb);
        vec3 color = colorRGBA.rgb;
        vec3 viewSpacePosition = vec3((farPlaneRay * depth).xy, -depth);

        vec3 vectorFromLight = viewSpacePosition - viewSpaceLightPos;
        vec3 directionToLight = normalize(-vectorFromLight);
        vec3 directionFromEye = normalize(viewSpacePosition);

        float diffuseReflectance = max(0.0, dot(directionToLight, normal));
        float visibility = 0.0;
        if (diffuseReflectance > 0.0 && !inShadow(shadowMap, invModelViewMatrix, vectorFromLight, EPS1, EPS2)) {
            visibility = 1.0;
        }

        vec3 fresnel = calculateFresnel(color, normal, directionFromEye);

        vec3 ambient = calculateAmbient(ambientLight, color);

        vec3 diffuse = vec3(0);
        vec3 specular = vec3(0);
        if (visibility > 0.01) {
            diffuse = calculateDiffuse(diffuseLight, color, diffuseReflectance);
            specular = calculateSpecular(specularLight, fresnel, materialShininess, normal, directionToLight, directionFromEye);
        }
        //vec3 emissive = materialEmissive;

        vec3 crepuscularRays = vec3(0);
        vec3 stepSize = viewSpacePosition / float(NUM_CREPUSCULAR_SAMPLES);
        vec3 intensity = crepuscularLight / float(NUM_CREPUSCULAR_SAMPLES);
        for (int i = 0; i < NUM_CREPUSCULAR_SAMPLES; i++) {
            vec3 pos = stepSize * float(i);
            if (!inShadow(shadowMap, invModelViewMatrix, pos - viewSpaceLightPos, EPS1, EPS2)) {
                crepuscularRays += intensity;
            }
        }
        
        // SSAO Implementation (http://john-chapman-graphics.blogspot.co.il/2013/01/ssao-tutorial.html)
        // TODO: Move scaling with render target size to uniforms
        // TODO: Move to separate shader for blur passes
        // TODO: Move radius to uniform
        vec3 randomVec = texture2D(noiseTexture, texCoord * vec2(1280.0/4.0, 720.0/4.0)).xyz;
        vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
        vec3 bitangent = cross(normal, tangent);
        mat3 invTBN = mat3(tangent, bitangent, normal);
        
        float occlusion = 0.0;
        #ifdef ENABLE_SSAO
        float radius = 0.75;
        for (int i = 0; i < NUM_SSAO_SAMPLES; i++) {
            vec3 sample = invTBN * hemisphere[i];
            sample = sample * radius + viewSpacePosition;
            
            vec4 offset = vec4(sample, 1.0);
            offset = projectionMatrix * offset;
            offset.xy /= offset.w;
            offset.xy = offset.xy * 0.5 + 0.5;
            
            float sampleDepth = -texture2D(normalDepthTexture, offset.xy).a;
            
            float rangeCheck = abs(viewSpacePosition.z - sampleDepth) < radius ? 1.0 : 0.0;
            occlusion += (sampleDepth > sample.z ? 1.0 : 0.0) * rangeCheck;
        }
        occlusion /= float(NUM_SSAO_SAMPLES);
        #endif
        occlusion = 1.0 - occlusion;
        
        gl_FragColor = vec4(vec3(0)
        + ambient * vec3(occlusion)
        + diffuse * visibility
        + specular * visibility
        + crepuscularRays
        , 1.0);
    }
</script>

<script type="text/javascript">
    // Shaders
    var preShader;
    var deferredShaderProgram;
    var shadowMapShader;

    // Render matrices
    var modelViewMatrix = mat4.create();
    var projectionMatrix = mat4.create();
    var shadowMapProjectionMatrix = mat4.create();
    var shadowMapModelViewMatrices = new Array();

    var lightPos = [8, 8, 8];
    var viewSpaceLightPos = new Array();

    var camera = new Camera([8, 8, 19], [0, 0, -1]);

    var chunks = new Array();

    var preFramebuffer;
    var shadowMapFramebuffer;
    var shadowMapFramebuffers;

    var normalDepthTexture;
    var normalTexture;
    var diffuseTexture;
    var cubeTexture;
    var depthTexture;
    var shadowMapTexture;

    var sceneFarPlane = 100;
    var shadowMapFarPlane = 100;
    var shadowMapSize = 512;

    var targetFPS = 60;
    var targetDelta = 1000/targetFPS;

    var moveSpeed = 0.1;
    var rotateSpeed = 0.05;


    function initShader(vs, fs, attributes, uniforms) {
        var shader = gl.createProgram();
        gl.attachShader(shader, getShader(gl, vs));
        gl.attachShader(shader, getShader(gl, fs));
        gl.linkProgram(shader);

        if (!gl.getProgramParameter(shader, gl.LINK_STATUS)) {
            alert("Could not initialise " + vs + "/" + fs + " shaders!");
        }

        gl.useProgram(shader);

        shader.vs = vs;
        shader.fs = fs;
        shader.attributes = {};
        shader.uniforms = {};

        for (val of attributes) {
            shader.attributes[val] = gl.getAttribLocation(shader, val);
            gl.enableVertexAttribArray(shader.attributes[val]);
        }

        for (val of uniforms) {
            shader.uniforms[val] = gl.getUniformLocation(shader, val);
        }

        return shader;
    }

    function reloadShader(shader) {
        gl.deleteProgram(shader);
        return initShader(shader.vs, shader.fs, Object.keys(shader.attributes), Object.keys(shader.uniforms));
    }
    
    function initShaders() {
        preShader = initShader(
            "pre-vs",
            "pre-fs",
            ["position", "normal", "tangent", "bitangent", "texCoordIn"],
            ["projectionMatrix", "modelViewMatrix", "normalTexture", "diffuseTexture", "depthMap"]
        );
        shadowMapShader = initShader(
            "shadow-map-vs",
            "shadow-map-fs",
            ["position"],
            ["projectionMatrix", "modelViewMatrix"]
        );
        deferredShader = initShader(
            "deferred-vs",
            "deferred-fs",
            ["position"],
            ["normalDepthTexture", "diffuseTexture", "viewSpaceLightPos", "invProjectionMatrix", "shadowMap", "invModelViewMatrix", "noiseTexture", "hemisphere", "projectionMatrix"]
        );
    }

    function setPreUniforms() {
        gl.uniformMatrix4fv(preShader.uniforms["projectionMatrix"], false, projectionMatrix);
        gl.uniformMatrix4fv(preShader.uniforms["modelViewMatrix"], false, modelViewMatrix);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
        gl.uniform1i(preShader.uniforms["diffuseTexture"], 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, normalTexture);
        gl.uniform1i(preShader.uniforms["normalTexture"], 1);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, depthMap);
        gl.uniform1i(preShader.uniforms["depthMap"], 2);
        gl.activeTexture(gl.TEXTURE0);
    }
    function setDeferredUniforms() {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.uniform1i(deferredShader.uniforms["normalDepthTexture"], 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, diffuseTexture);
        gl.uniform1i(deferredShader.uniforms["diffuseTexture"], 1);
        gl.uniform3fv(deferredShader.uniforms["viewSpaceLightPos"], viewSpaceLightPos);
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, shadowMapTexture);
        gl.uniform1i(deferredShader.uniforms["shadowMap"], 2);

        gl.activeTexture(gl.TEXTURE3);
        gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
        gl.uniform1i(deferredShader.uniforms["noiseTexture"], 3);
        gl.uniform3fv(deferredShader.uniforms["hemisphere"], hemisphereArray);
        gl.uniformMatrix4fv(deferredShader.uniforms["projectionMatrix"], false, projectionMatrix);
        
        var invProjectionMatrix = mat4.create();
        mat4.inverse(projectionMatrix, invProjectionMatrix);
        gl.uniformMatrix4fv(deferredShader.uniforms["invProjectionMatrix"], false, invProjectionMatrix);
        gl.activeTexture(gl.TEXTURE0);

        var invModelViewMatrix = mat4.create();
        mat4.inverse(modelViewMatrix, invModelViewMatrix);
        gl.uniformMatrix4fv(deferredShader.uniforms["invModelViewMatrix"], false, invModelViewMatrix);
    }
    function setShadowMapUniforms(face) {
        gl.uniformMatrix4fv(shadowMapShader.uniforms["projectionMatrix"], false, shadowMapProjectionMatrix);
        gl.uniformMatrix4fv(shadowMapShader.uniforms["modelViewMatrix"], false, shadowMapModelViewMatrices[face]);
    }

    function initFramebuffers(width, height) {

        normalTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, normalTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 0, 255, 255]));
        var image2 = new Image();
        image2.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, normalTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image2.src = cubeTextureData.normalMap;

        cubeTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
        var image = new Image();
        image.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, cubeTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image.src = cubeTextureData.data;

        
        depthMap = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthMap);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));
        var image3 = new Image();
        image3.addEventListener('load', function() {
            gl.bindTexture(gl.TEXTURE_2D, depthMap);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image3);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.generateMipmap(gl.TEXTURE_2D);
        });
        image3.src = cubeTextureData.depthMap;
        
        var depthExt = gl.getExtension("WEBGL_depth_texture");
        if (!depthExt) {
            console.log("no depth textures");
        }

        diffuseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, diffuseTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        normalDepthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        depthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, width, height, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);

        // PRE FRAMEBUFFER
        preFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, preFramebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, mrtExt.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, diffuseTexture, 0);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, mrtExt.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, normalDepthTexture, 0);

        mrtExt.drawBuffersWEBGL([
            mrtExt.COLOR_ATTACHMENT0_WEBGL,
            mrtExt.COLOR_ATTACHMENT1_WEBGL
        ]);

        shadowMapFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffer);
        // SHADOW MAP STUFF
        shadowMapTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, shadowMapTexture);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        for (var i = 0; i < 6; i++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, shadowMapSize, shadowMapSize, 0, gl.RGBA, gl.FLOAT, null);
        }

        var shadowMapDepthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, shadowMapDepthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, shadowMapSize, shadowMapSize);

        shadowMapFramebuffers = new Array(6);
        for (var i = 0; i < 6; i++) {
            // Different framebuffers for every face, it is much faster:
            // http://jsperf.com/webgl-cubemap-fbo-change-face-test
            shadowMapFramebuffers[i] = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffers[i]);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, shadowMapTexture, 0);
            
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, shadowMapDepthBuffer);
        }

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function handleInput(delta) {
        if (isKeyDown(38) || isKeyDown(87)) { // UP / W
            camera.move([0, 0, moveSpeed * delta]);
        }
        if (isKeyDown(37) || isKeyDown(65)) { // LEFT / A
            camera.rotate([0, rotateSpeed * delta, 0]);
        }
        if (isKeyDown(40) || isKeyDown(83)) { // DOWN / S
            camera.move([0, 0, -moveSpeed * delta]);
        }
        if (isKeyDown(39) || isKeyDown(68)) { // RIGHT / D
            camera.rotate([0, -rotateSpeed * delta, 0]);
        }
        if (isKeyDown(81)) { // Q
            camera.move([-moveSpeed * delta, 0, 0]);
        }
        if (isKeyDown(69)) { // E
            camera.move([moveSpeed * delta, 0, 0]);
        }
    }

    function setupScene() {
        var chunk = new Chunk();
        chunk._blocks[7][8][7].SetActive(true);
        chunk._blocks[7][9][7].SetActive(true);
        chunk._blocks[7][9][8].SetActive(true);
        chunk._blocks[8][9][7].SetActive(true);

        chunk._blocks[9][8][9].SetActive(true);
        chunk._blocks[9][7][8].SetActive(true);
        chunk._blocks[9][7][9].SetActive(true);
        chunk._blocks[8][7][9].SetActive(true);

        chunk._blocks[1][7][8].SetActive(true);
        chunk._blocks[1][8][8].SetActive(true);
        chunk._blocks[1][9][8].SetActive(true);

        chunk._blocks[3][7][8].SetActive(true);
        chunk._blocks[3][8][8].SetActive(true);
        chunk._blocks[3][9][8].SetActive(true);

        chunk._blocks[5][7][8].SetActive(true);
        chunk._blocks[5][8][8].SetActive(true);
        chunk._blocks[5][9][8].SetActive(true);

        for (var i = 0; i < Chunk.SIZE; i++) {
            for (var j = 0; j < Chunk.SIZE; j++) {
                chunk._blocks[i][6][j].SetActive(true); // Floor
                chunk._blocks[i][10][j].SetActive(true); // Ceiling
                chunk._blocks[i][j][6].SetActive(true); // Far wall
            }
        }
        chunk.CreateMesh();
        chunks.push(chunk);
    }

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, sceneFarPlane, projectionMatrix);

        modelViewMatrix = camera.viewMatrix();

        mat4.multiplyVec3(modelViewMatrix, lightPos, viewSpaceLightPos);

        gl.bindFramebuffer(gl.FRAMEBUFFER, preFramebuffer);
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0, 0, 0, 100.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.useProgram(preShader);
        setPreUniforms();

        for (var i = 0; i < chunks.length; i++) {
            chunks[i].SetPositions(preShader);
            chunks[i].SetNormals(preShader);
            chunks[i].SetTangents(preShader);
            chunks[i].SetBitangents(preShader);
            chunks[i].SetTexCoords(preShader);
            chunks[i].Render(preShader);
        }
    }

    function drawShadowMap() {
        mat4.perspective(90, 1, 0.1, shadowMapFarPlane, shadowMapProjectionMatrix);
        shadowMapModelViewMatrices[0] = mat4.lookAt(lightPos, [lightPos[0] + 1, lightPos[1], lightPos[2]], [0, -1,  0]);
        shadowMapModelViewMatrices[1] = mat4.lookAt(lightPos, [lightPos[0] - 1, lightPos[1], lightPos[2]], [0, -1,  0]);
        shadowMapModelViewMatrices[2] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1] + 1, lightPos[2]], [0,  0,  1]);
        shadowMapModelViewMatrices[3] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1] - 1, lightPos[2]], [0,  0, -1]);
        shadowMapModelViewMatrices[4] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1], lightPos[2] + 1], [0, -1,  0]);
        shadowMapModelViewMatrices[5] = mat4.lookAt(lightPos, [lightPos[0], lightPos[1], lightPos[2] - 1], [0, -1,  0]);

        gl.clearColor(shadowMapFarPlane, shadowMapFarPlane, shadowMapFarPlane, shadowMapFarPlane);
        gl.viewport(0, 0, shadowMapSize, shadowMapSize);
        for (var i = 0; i < 6; i++) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, shadowMapFramebuffers[i]);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            gl.useProgram(shadowMapShader);
            setShadowMapUniforms(i);

            for (var j = 0; j < chunks.length; j++) {
                chunks[j].SetPositions(shadowMapShader);
                chunks[j].Render(shadowMapShader);
            }
        }
    }
var numSSAOSamples = 64;
var noiseTexture;
var hemisphereArray;
    function generateSSAOhemisphere() {
        hemisphereArray = new Array();
        for (var i = 0; i < numSSAOSamples; i++) {
            var hemisphere = [
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                Math.random()
            ];
            vec3.normalize(hemisphere);
            vec3.scale(hemisphere, Math.random());
            
            var scale = i / numSSAOSamples;
            scale = (1 - scale * scale) * 0.1 + scale * scale; // Lerp
            vec3.scale(hemisphere, scale);
            hemisphereArray = hemisphereArray.concat(hemisphere);
        }
    }
    function generateSSAONoiseTexture() {
        var noiseTextureSize = 4;
        var noiseArray = new Array();
        for (var i = 0; i < noiseTextureSize * noiseTextureSize * 3; i += 3) {
            var noise = [
                Math.random() * 2 - 1,
                Math.random() * 2 - 1,
                0
            ];
            vec3.normalize(noise);
            noiseArray = noiseArray.concat(noise);
        }
        noiseTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, noiseTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, noiseTextureSize, noiseTextureSize, 0, gl.RGB, gl.FLOAT, new Float32Array(noiseArray));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }
    
    function drawDeferred() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.useProgram(deferredShader);
        setDeferredUniforms();
        drawFullscreenQuad(deferredShader);
    }

    function render() {
        drawScene();
        drawShadowMap();
        drawDeferred();
    }

    function webGLStart() {

        // Init everything
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        initFramebuffers(gl.viewportWidth, gl.viewportHeight);

        setupScene();

        generateSSAOhemisphere();
        generateSSAONoiseTexture();

        // Setup permanent stuff
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);

        var stats1 = new frameTimeStats(10, document.getElementById("fps-text1"));
        var stats2 = new frameTimeStats(50, document.getElementById("fps-text2"));
        var stats3 = new frameTimeStats(100, document.getElementById("fps-text3"));

        var rendererInformation = new rendererInfo(document.getElementById("renderer-info"));

        var time = 0;

        // Start the game loop
        var last = performance.now();
        (function gameLoop(now){
            var delta = now - last;
            
            stats1.addSample(delta);
            stats2.addSample(delta);
            stats3.addSample(delta);

            rendererInformation.display();

            handleInput(delta/targetDelta);
            render();

            time += delta;
            lightPos[0] = 8 + Math.sin(time / 1000.0);

            last = now;

            requestAnimationFrame(gameLoop);
        })(performance.now());
    }
</script>
</head>
<body onload="webGLStart();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
    <p id="fps-text1"></p>
    <p id="fps-text2"></p>
    <p id="fps-text3"></p>
    <p id="renderer-info"></p>
    
    <p>
        <label for="number-god-ray-samples">Number of God Ray samples:</label>
        <input type="number" id="number-god-ray-samples" min="0" max="100" value="100" />
    </p>
    <p>
        <label for="number-ssao-samples">Number of SSAO samples:</label>
        <input type="number" id="number-ssao-samples" min="0" max="100" value="64" />
    </p>
    <p>
        <label for="enable-parallax">Enable Parallax Mapping: </label>
        <input type="checkbox" id="enable-parallax" checked />
    </p>
        <p>
        <label for="enable-normal-mapping">Enable Normal Mapping: </label>
        <input type="checkbox" id="enable-normal-mapping" checked />
    </p>
        <p>
        <label for="enable-diffuse-texture">Enable Diffuse Texture: </label>
        <input type="checkbox" id="enable-diffuse-texture" checked />
    </p>
    <script type="text/javascript">
    
    function setDefined(shaderElem, define, string, value) {
        shaderElem.innerHTML = shaderElem.text.replace(
            new RegExp("(#undef|#define)\\s+" + string + "( +\\S+)?"),
            (define ? "#define " : "#undef ") + string + (value != null ? " " + value : "")
        );
    }
    
    var numGodRaySamplesInput = document.getElementById("number-god-ray-samples");
    var numSSAOSamplesInput = document.getElementById("number-ssao-samples");
    var parallaxInput = document.getElementById("enable-parallax");
    var normalMappingInput = document.getElementById("enable-normal-mapping");
    var diffuseTextureInput = document.getElementById("enable-diffuse-texture");
    
    numGodRaySamplesInput.onchange = function() {
        setDefined(document.getElementById("deferred-fs"), true,
                   "NUM_CREPUSCULAR_SAMPLES",
                   numGodRaySamplesInput.value);
        deferredShader = reloadShader(deferredShader);
    }

    numSSAOSamplesInput.onchange = function() {
        var value = numSSAOSamplesInput.value;
        numSSAOSamples = value;
        if (value == null || value <= 0) {
            setDefined(document.getElementById("deferred-fs"), false, "ENABLE_SSAO");
        }
        else {
            setDefined(document.getElementById("deferred-fs"), true, "ENABLE_SSAO");
            setDefined(document.getElementById("deferred-fs"), true,
                       "NUM_SSAO_SAMPLES",
                       value);
        }
        deferredShader = reloadShader(deferredShader);
    }
    
    parallaxInput.onchange = function() {
        setDefined(document.getElementById("pre-fs"), parallaxInput.checked, "PARALLAX_MAPPING");
        preShader = reloadShader(preShader);
    }
    
    normalMappingInput.onchange = function() {
        setDefined(document.getElementById("pre-fs"), normalMappingInput.checked, "NORMAL_MAPPING");
        preShader = reloadShader(preShader);
    }
    
    diffuseTextureInput.onchange = function() {
        setDefined(document.getElementById("pre-fs"), diffuseTextureInput.checked, "DIFFUSE_TEXTURE");
        preShader = reloadShader(preShader);
    }
    
    </script>
</body>
</html>
