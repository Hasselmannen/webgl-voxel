<html>

<head>
<title>Voxel</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="camera.js"></script>
<script type="text/javascript" src="gl-stuff.js"></script>
<script type="text/javascript" src="voxel-stuff.js"></script>
<script type="text/javascript" src="util.js"></script>

<script id="normal-depth-vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec3 normal;
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;

    varying vec3 viewSpacePosition;
    varying vec3 viewSpaceNormal;
    
    void main(void) {
        viewSpacePosition = vec3(modelViewMatrix * vec4(position, 1));
        viewSpaceNormal = vec3(modelViewMatrix * vec4(normal, 0));
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="normal-depth-fs" type="x-shader/x-fragment">
    precision highp float;

    varying vec3 viewSpacePosition;
    varying vec3 viewSpaceNormal;
    
    void main(void) {
        vec3 normal = normalize(viewSpaceNormal);
        
        gl_FragColor = vec4(normal, -viewSpacePosition.z);
    }
</script>

<script id="color-vs" type="x-shader/x-vertex">
    attribute vec3 position;
    attribute vec3 normal;
    
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    
    void main(void) {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="color-fs" type="x-shader/x-fragment">
    precision highp float;
    
    void main(void) {    
        gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0);
    }
</script>

<script id="deferred-shader-vs" type="x-shader/x-vertex">
    precision highp float;
    
    attribute vec2 position;
    
    uniform mat4 invProjectionMatrix;
    
    varying vec2 texCoord;
    varying vec3 farPlaneRay;
    
    const vec2 scale = vec2(0.5, 0.5);
    
    void main(void) {
        texCoord = position * scale + scale;
        farPlaneRay = (invProjectionMatrix * vec4(position, 0.0, 0.0)).xyz;
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>
<script id="deferred-shader-fs" type="x-shader/x-fragment">
    precision highp float;
    
    varying vec2 texCoord;
    varying vec3 farPlaneRay;
    
    uniform vec3 viewSpaceLightPos;
    
    uniform sampler2D normalDepthTexture;
    uniform sampler2D colorTexture;
    
    vec3 ambientLight = vec3(0.2, 0.2, 0.2);
    vec3 diffuseLight = vec3(0.9, 0.9, 0.5);
    vec3 specularLight = vec3(0.9, 0.9, 0.5);
    
    float materialShininess = 5.0;
    
    vec3 calculateAmbient(vec3 ambientLight, vec3 materialAmbient) {
        return ambientLight * materialAmbient;
    }
    
    vec3 calculateDiffuse(vec3 diffuseLight, vec3 materialDiffuse, float diffuseReflectance) {
        return diffuseLight * materialDiffuse * diffuseReflectance;
    }
    
    vec3 calculateFresnel(vec3 materialSpecular, vec3 normal, vec3 directionFromEye) {
        return materialSpecular + (vec3(1.0) - materialSpecular) * pow(clamp(1.0 + dot(directionFromEye, normal), 0.0, 1.0), 5.0);
    }

    vec3 calculateSpecular(vec3 specularLight, vec3 materialSpecular, float materialShininess, vec3 normal, vec3 directionToLight, vec3 directionFromEye) {
        float normalizationFactor = ((materialShininess + 2.0) / 8.0);
        vec3 h = normalize(directionToLight - directionFromEye);
        return specularLight * materialSpecular * pow(max(dot(h, normal), 0.0), materialShininess) * normalizationFactor;
    }
    
    
    void main(void) {
        vec4 normalDepth = texture2D(normalDepthTexture, texCoord);
        vec4 colorRGBA = texture2D(colorTexture, texCoord);
        
        float depth = normalDepth.a;
        float alpha = colorRGBA.a;
        vec3 normal = normalize(normalDepth.rgb);
        vec3 color = colorRGBA.rgb;
        vec3 viewSpacePosition = vec3((farPlaneRay * depth).xy, -depth);
        
        vec3 directionToLight = normalize(viewSpaceLightPos - viewSpacePosition);
        vec3 directionFromEye = normalize(viewSpacePosition);
        
        float diffuseReflectance = max(0.0, dot(directionToLight, normal));
        float visibility = 0.0;
        if (diffuseReflectance > 0.0) {
            visibility = 1.0;
        }
        vec3 fresnel = calculateFresnel(color, normal, directionFromEye);
        
        vec3 ambient = calculateAmbient(ambientLight, color);
        
        vec3 diffuse = vec3(0);
        vec3 specular = vec3(0);
        if (visibility > 0.01) {
            diffuse = calculateDiffuse(diffuseLight, color, diffuseReflectance);
            specular = calculateSpecular(specularLight, fresnel, materialShininess, normal, directionToLight, directionFromEye);
        }
        //vec3 emissive = materialEmissive;

        gl_FragColor = vec4(vec3(0)
        + ambient
        + diffuse * visibility
        + specular * visibility
        , 1.0);
    }
</script>


<script id ="edge-detection-vs" type="x-shader/x-vertex">
    precision highp float;
    
    attribute vec2 position;
    
    varying vec2 texCoord;
    
    const vec2 scale = vec2(0.5, 0.5);
    
    void main(void) {
        texCoord = position * scale + scale;
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>
<script id ="edge-detection-fs" type="x-shader/x-fragment">
    precision highp float;
    
    varying vec2 texCoord;
    
    uniform sampler2D texture;
    
    void main(void) {
        gl_FragColor = vec4(vec3(0)
        , 1.0);
    }

</script>

<script type="text/javascript">
    // Shaders
    var normalDepthShader;
    var colorShader;
    var deferredShaderProgram;
    var edgeDetectionShader;
    
    // Render matrices
    var modelViewMatrix = mat4.create();
    var projectionMatrix = mat4.create();
    var viewSpaceLightPos = [];

    var camera = new Camera([8, 8, 19], [0, 0, -1]);
    
    var chunks = new Array();
    
    var normalDepthFramebuffer;
    var normalDepthTexture;
    var colorFramebuffer;
    var colorTexture;
    
    var targetFPS = 60;
    var targetDelta = 1000/targetFPS;
    
    var moveSpeed = 0.1;
    var rotateSpeed = 0.05;
    
    function initShader(vs, fs, attributes, uniforms) {
        var shader = gl.createProgram();
        gl.attachShader(shader, getShader(gl, vs));
        gl.attachShader(shader, getShader(gl, fs));
        gl.linkProgram(shader);
        
        gl.useProgram(shader);
        
        shader.attributes = {};
        shader.uniforms = {};
        
        for (val of attributes) {
            shader.attributes[val] = gl.getAttribLocation(shader, val);
            gl.enableVertexAttribArray(shader.attributes[val]);
        }
        
        for (val of uniforms) {
            shader.uniforms[val] = gl.getUniformLocation(shader, val);
        }
        
        return shader;
    }

    function initShaders() {
        normalDepthShader = initShader(
            "normal-depth-vs",
            "normal-depth-fs",
            ["position", "normal"],
            ["projectionMatrix", "modelViewMatrix"]
        );
        colorShader = initShader(
            "color-vs", "color-fs",
            ["position"],
            ["projectionMatrix", "modelViewMatrix"]
        );
        deferredShader = initShader(
            "deferred-shader-vs",
            "deferred-shader-fs",
            ["position"],
            ["normalDepthTexture", "colorTexture", "viewSpaceLightPos", "invProjectionMatrix"]
        );
        edgeDetectionShader = initShader(
            "edge-detection-vs",
            "edge-detection-fs",
            ["position"],
            ["texture"]
        );
    }
    
    function setNormalDepthUniforms() {
        gl.uniformMatrix4fv(normalDepthShader.uniforms["projectionMatrix"], false, projectionMatrix);
        gl.uniformMatrix4fv(normalDepthShader.uniforms["modelViewMatrix"], false, modelViewMatrix);
    }
    
    function setColorUniforms() {
        gl.uniformMatrix4fv(colorShader.uniforms["projectionMatrix"], false, projectionMatrix);
        gl.uniformMatrix4fv(colorShader.uniforms["modelViewMatrix"], false, modelViewMatrix);
    }
    
    function setDeferredUniforms() {
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.uniform1i(deferredShader.uniforms["normalDepthTexture"], 0);
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
        gl.uniform1i(deferredShader.uniforms["colorTexture"], 1);
        
        gl.uniform3fv(deferredShader.uniforms["viewSpaceLightPos"], viewSpaceLightPos);
        
        var invProjectionMatrix = mat4.create();
        mat4.inverse(projectionMatrix, invProjectionMatrix);
        gl.uniformMatrix4fv(deferredShader.uniforms["invProjectionMatrix"], false, invProjectionMatrix);
    }
    
    function initFramebuffers(width, height) {
        // NORMAL-DEPTH FRAMEBUFFER
    
        normalDepthFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, normalDepthFramebuffer);
        normalDepthFramebuffer.width = width;
        normalDepthFramebuffer.height = height;
        
        normalDepthTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, normalDepthTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, null);

        var normalDepthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, normalDepthRenderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, normalDepthTexture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, normalDepthRenderbuffer);
        
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        
        // COLOR FRAMEBUFFER
        
        colorFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, colorFramebuffer);
        colorFramebuffer.width = width;
        colorFramebuffer.height = height;
        
        colorTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, colorTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        var colorRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, colorRenderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, colorRenderbuffer);
        
        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    
    function handleInput(delta) {
        if (isKeyDown(38) || isKeyDown(87)) { // UP / W
            camera.move([0, 0, moveSpeed * delta]);
        }
        if (isKeyDown(37) || isKeyDown(65)) { // LEFT / A
            camera.rotate([0, rotateSpeed * delta, 0]);
        }
        if (isKeyDown(40) || isKeyDown(83)) { // DOWN / S
            camera.move([0, 0, -moveSpeed * delta]);
        }
        if (isKeyDown(39) || isKeyDown(68)) { // RIGHT / D
            camera.rotate([0, -rotateSpeed * delta, 0]);
        }
        if (isKeyDown(81)) { // Q
            camera.move([-moveSpeed * delta, 0, 0]);
        }
        if (isKeyDown(69)) { // E
            camera.move([moveSpeed * delta, 0, 0]);
        }
    }

    function setupScene() {
        var chunk = new Chunk();
        chunk._blocks[7][8][7].SetActive(true);
        chunk._blocks[7][9][7].SetActive(true);
        chunk._blocks[7][9][8].SetActive(true);
        chunk._blocks[8][9][7].SetActive(true);

        chunk._blocks[9][8][9].SetActive(true);
        chunk._blocks[9][7][8].SetActive(true);
        chunk._blocks[9][7][9].SetActive(true);
        chunk._blocks[8][7][9].SetActive(true);
        
        chunk._blocks[1][7][8].SetActive(true);
        chunk._blocks[1][8][8].SetActive(true);
        chunk._blocks[1][9][8].SetActive(true);
        
        chunk._blocks[3][7][8].SetActive(true);
        chunk._blocks[3][8][8].SetActive(true);
        chunk._blocks[3][9][8].SetActive(true);
        
        chunk._blocks[5][7][8].SetActive(true);
        chunk._blocks[5][8][8].SetActive(true);
        chunk._blocks[5][9][8].SetActive(true);
        
        for (var i = 0; i < Chunk.SIZE; i++) {
            for (var j = 0; j < Chunk.SIZE; j++) {
                chunk._blocks[i][6][j].SetActive(true); // Floor
                chunk._blocks[i][10][j].SetActive(true); // Ceiling
                
                chunk._blocks[i][j][6].SetActive(true); // Far wall
                
            }
        }
        
        chunk.CreateMesh();
        chunks.push(chunk);
    }
    
    function drawScene() {
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, projectionMatrix);

        modelViewMatrix = camera.viewMatrix();
        
        var lightPos = [8, 8, 8];
        mat4.multiplyVec3(modelViewMatrix, lightPos, viewSpaceLightPos);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, normalDepthFramebuffer);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(normalDepthShader);
        setNormalDepthUniforms();
        
        for (var i = 0; i < chunks.length; i++) {
            chunks[i].SetPositions(normalDepthShader);
            chunks[i].SetNormals(normalDepthShader);
            chunks[i].Render(normalDepthShader);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, colorFramebuffer);
        gl.enable(gl.DEPTH_TEST);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(colorShader);
        setColorUniforms();
        
        for (var i = 0; i < chunks.length; i++) {
            chunks[i].SetPositions(colorShader);
            chunks[i].Render(colorShader);
        }
    }
    
    function render() {
        
        drawScene();
        
        // Bind framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.useProgram(deferredShader);
        setDeferredUniforms();
        drawFullscreenQuad(deferredShader);
    }
    
    function webGLStart() {
        
        // Init everything
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        initFramebuffers(gl.viewportWidth, gl.viewportHeight);
        setupScene();
        
        // Setup permanent stuff
        gl.clearColor(100/255, 149/255, 237/255, 1.0);
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);
        
        // Start the render loop
        var last = performance.now();
        (function gameLoop(now){
            var delta = now - last;
            var fps = 1000 / delta;
            
            handleInput(delta/targetDelta);
            render();
            
            last = now;
            
            requestAnimationFrame(gameLoop);
        })(performance.now());
    }
</script>
</head>
<body onload="webGLStart();">
    <canvas id="canvas" style="border: none;" width="1280" height="720"></canvas>
</body>
</html>
